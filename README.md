[![Coverage Status](https://coveralls.io/repos/github/lad-tech/nsc-toolkit/badge.svg?branch=main)](https://coveralls.io/github/lad-tech/nsc-toolkit?branch=main)
[![Known Vulnerabilities](https://snyk.io/test/github/lad-tech/nsc-toolkit/badge.svg)](https://snyk.io/test/github/lad-tech/nsc-toolkit)

## О библиотеке

`nsc-toolkit (NATS service creator toolkit)` 一 это набор инструментов для создания сервис-ориентированной архитектуры.

Основная идеология тулкита заключается в установке минимального количества зависимостей, что позволяет создавать сервисы с помощью инструментов кодогенерации на основе простого описания в JSON-формате.

Основным средством коммуникации между сервисами в обычном режиме работы является брокер сообщений [NATS](https://nats.io/). Применяются четыре основных способа:

1. Синхронный (`request`/`reply`) через брокер сообщений. Используется, если одному сервису, чтобы продолжать выполнять свою логику, требуются данные из другого сервиса.
2. События (`pub`/`sub`). События используются, когда сервису необходимо оповестить другие сервисы о произошедшем событии, но кто слушает и обрабатывает эти события, сервису неизвестно. Это дает возможность строить независимые между собой сервисы для создания архитектуры на основе событий 一 Event-driven architecture (EDA).
3. Web-потоки на основе `HTTP 1.1`. Этот метод используется, если сервису требуется передать в другой сервис поток данных. Например, список из миллиона пользователей или любые другие объемные данные, включая бинарные. Тогда брокер выступает только как средство балансировки нагрузки и не участвует в передаче данных напрямую. Данные передаются с помощью web-потока из одного сервиса в другой через прямое соединение. Метод сервиса в качестве входных параметров может принимать поток данных и отдавать его в качестве ответа.
4. Jet-streams используют возможности брокера NATS. Jet-streams похож на `pub`/`sub`, но предоставляет возможность хранить сообщения на самом брокере. Такой тип коммуникации позволяет реализовывать более безопасный способ общения между сервисами на основе событий. События, если на них нет подписчиков на текущий момент, не пропадут, а сохранятся на самом брокере.

Все четыре способа коммуникации между сервисами реализуются средствами библиотеки и описываются в JSON.

## Возможности

- Простота и минимальное количество зависимостей за счет снижения уровня вариативности
- Схема взаимодействия `request`/`reply`
- Схема взаимодействия `pub`/`sub`
- Использование Web-streams
- Использование Jet-streams
- Сквозной таймаут для запросов
- Трассировки
- Межсервисное кэширование
- Валидация входных и выходных параметров методов сервиса на основе [JSON Schema](https://json-schema.org/).
- Логирование с учетом контекста
- Декораторы для инъекции зависимостей в методы сервиса
- Сервисный http-маршрут для проб, который поднимается вместе со стартом сервиса (доступен `GET [host]/healthcheck HTTP/1.1`)
- Сворачивание написанных сервисов в монолитное приложение без использования брокера NATS с сохранением всего спектра перечисленных функциональностей. Разные типы архитектуры (микросервисы или монолит) собираются из одной кодовой базы. Это может происходить параллельно в одном пайплайне CI/CD.

## Быстрый старт

Для обзора возможностей библиотеки рекомендуется использовать пример из каталога `examples`, который состоит из 3-х сервисов. Подробно реализация логики описана в пункте [Пример использования](#пример-использования).

Для того, чтобы запустить пример, необходимо:

1. клонировать репозиторий с библиотекой и установить зависимости:

```
npm i
```

2. дополнительно зайти в каталог `examples` с сервисом `HttpGate`

```
cd ./examples/HttpGate
```

и установить там зависимости, так как для реализации HTTP-API используется библиотека Fastify:

```
npm i
```

3. после установки зависимостей можно запустить сервисы.

### Переменные окружения

- `DEFAUL_RESPONSE_TIMEOUT` 一 внешнее ограничение тайм-аута при запросе в секундах. Используется при первоначальном формировании времени тайм-аута в багаже по формуле `Date.now() + DEFAULT_RESPONSE_TIMEOUT`;
- `OTEL_AGENT` 一 хост агента по сбору распределенных трассировок.

## Основные компоненты библиотеки

Для реализации сервисов используются следующие компоненты:

1. Файл service.schema.json. Каждый сервис в первую очередь описывается с помощью формата json. Схема описания следующая.

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "methods": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "action": { "type": "string" },
          "description": { "type": "string" },
          "options": { "$ref": "#/$defs/options" },
          "request": { "type": "object" },
          "response": { "type": "object" }
        },
        "required": ["action", "description", "options"]
      }
    },
    "events": {
      "type": "object",
      "properties": {
        "list": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "action": { "type": "string" },
              "options": {
                "type": "object",
                "properties": {
                  "stream": { "type": "boolean" }
                },
              },
              "description": { "type": "string" },
              "event": { "type": "object" }
            },
            "required": ["action", "description", "event"]
          },
        },
        "streamOptions": {
          "type": "object",
          "properties": {
            "prefix": { "type": "string" },
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "action": { "type": "string" },
                  "storage": { "type": "string" },
                  "retentionPolicy": { "type": "string" },
                  "discardPolicy": { "type": "string" },
                  "messageTTL": { "type": "number" },
                  "duplicateTrackingTime": { "type": "number" },
                  "replication": { "type": "number" },
                  "rollUps": { "type": "boolean" }
                },
                "required": ["action"]
              }
            }
          },
          "required": ["prefix", "actions"]
        }
      },
      "required": ["list"]
    }
  },
  "required": ["name", "description", "methods"],

  "$defs": {
    "options": {
      "type": "object",
      "properties": {
        "useStream": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        },
        "cache": { "type": "number" },
        "runTimeValidation": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        }
      }
    }
  }
}
```

- `name` 一 название сервиса;
- `description` 一 описание сервиса;
- `methods` 一 набор методов для реализации схемы `request`/`reply`;
  - `action` 一 идентификатор запроса;
  - `description` 一 описание метода;
  - `request` 一 JSON Schema входных данных;
  - `response` 一 JSON Schema выходных данных;
  - `options` 一 настройки метода;
    - `useStream` 一 использование Web-стримов для входных и выходных данных;
      - `request` 一 Web-стрим на входе;
      - `response` 一 Web-стрим на выходе;
    - `cache` 一 кэширование запроса (задается в минутах);
    - `runTimeValidation` 一 использование runtime для валидации параметров;
      - `request` 一 для входных данных;
      - `response` 一 для выходных данных;
- `events` 一 набор событий, генерируемый сервисом для реализации схемы `pub`/`sub`;
  - `list` - массив объектов событий генерируемых сервисом;
    - `action` - идентификатор события;
    - `description` - описание события;
    - `options` - необязательные настройки события;
      - `stream` - булевый флаг говорящий о том, что событие является стримом;
    - `event` - JSON Schema события;
  - `name` 一 идентификатор события;
  - `description` 一 описание события;
  - `event` 一 JSON Schema события;
- `streamOptions` - настройки стрима;
  - `prefix` - префикс ко всем темам у которых включена опция stream: true;
  - `actions` - массив объектов настроек стримов;
    - `action` - паттерн для тем на которые будут применяться данные настройки. Если указана * то применяется ко всем событиям с опцией stream: true;
    - `storage` - Где будут храниться сообщения стрима. Доступные варианты 'file' | 'memory'. По умолчанию 'file';
    - `retentionPolicy` - По каким правилам будут удаляться сообщения из стрима. Доступные варианты 'limits' | 'interest' | 'workQueue'. По умолчанию 'limits';
    - `discardPolicy` - Определяет какие сообщения будут отброшены при достижении лимита. Доступные варианты 'old' | 'new'. По умолчанию `old`;
    - `messageTTL` - Срок жизни сообщения. Задается в секундах. По умолчанию 2 недели;
    - `duplicateTrackingTime` - Временной отрезок на котором работает дедубликация сообщений. Задается в секундах. По умолчанию 1 день;
    - `replication` - Количество реплик стрима. По умолчанию 1;
    - `rollUps` - Флаг разрешающий удалить все сообщения из стрима. По умолчанию true;

Файл позволяет описать все возможности создаваемого сервиса. Его синхронные методы, генерируемые сообщения и описать при необходимости настройки стримов для сообщений. Сервис предполагается создавать из описания с помощью кодогенерации. Библиотека для кодогенерации сервиса из описания [nsc-cli](https://github.com/lad-tech/nsc-cli).

2. Класс Service. Для того чтобы создать сервис необходимо создать экземпляр этого класса и вызвать метод start. Принимаемые параметры при создании экземпляра.

- `name` - имя сервиса;
- `brokerConnection` - подключение к брокеру NATS. Параметр необязательный. Если не передать будет использоваться внутренняя реализация брокера. Это необходимо для реализации возможности сборки сервисов в монолитное приложение;
- `methods` - массив методов. BaseMethod это еще один базовый класс библиотеки. Для того что бы создать метод с бизнес-логикой, необходимо расширить класс BaseMethod;
- `events` - описание генерируемых событий. Следует передать весь блок events из service.schema.json;
- `cache` - настройки межмикросервисного кеширования;
  - `service` - реализация интерфеса сервиса кеширования;
  - `timeout` - время в рамках которого необходимо ожидать ответа от кеша. Задается в миллисекундах;
- `loggerOutputFormatter` - реализация класса форматера для логов. Для логирования используется библиотека [@lad-tech/toolbelt](https://github.com/lad-tech/toolbelt);
- `gracefulShutdown` - настройки по завершению работы сервиса;
  - `additional` - массив дополнительных сервисов, которые могут завершать свою работу. Необходимо чтобы сервисы реализовывали необходимый интерфейс;
  - `timeout` - время в рамках которого стоит ожидать штатной остановки сервиса;

Публичные методы:

- `getRootBaggage` - получить корневой багаж для распределенной трассировки. Источником может служить заголовки http запроса. Если подобного рода источники отсутствуют создается новый корневой багаж;
- `endRootSpan` - завершение корневого Span по id трассировки. Необхлдимо для внедорения распределенных трассировок;
- `buildService` - метод создает экземпляр клиента. Все используемые при запросах клиенты (сервисы), для использования полного функционала билбиотеки, должны создаваться через этот метод;
- `start` - запуск сервиса;
- `stop` - остановка сервиса;

3. Класс Client. Для того чтобы создать клиент для сервиса необходимо расширить класс Client и описать в нем все доступные из вне вызовы методов. Для вызова метода используется приватный метод CLient.request. Пример создания клиента можно [посмотреть тут](./examples/MathService/index.ts).

Публичные методы:

- `getListener` - метод получения объекта EventEmitter для подписки на события сервиса;

4. Декораторы. Если в методе сервиса используется вызов метода другого сервиса то клиент сервиса зависимости следует подключить через декоратор @service, а к самому классу метода применить декоратор @related. В этом случае при вызове метода сервиса не пропадет контекст запроса и можно будет использовать распределенные трассировки. Также инъекция через декоратор @service позволяет использовать функционал сборки приложения в монолит. Для инъекции других зависимостей например объектов репозиториев используется декоратор @instance. В него можно передать готовый объект с набором асинхронных методов и при вызове этих методов, из логики метода, они будут видны в трассировках. Для получения таких зависимостей рекомендуется использовать DI контейнеры.

## Рекомендации

Библиотека задумана как инструмент не диктующий жестких правил, но в тоже время библиотека спроектирована с учетом исполнения следующих рекомендаций:

- Использование кодогенерации на основе описания сервиса в файле service.schema.json с помощью библиотеки [nsc-cli](https://github.com/lad-tech/nsc-cli). На основе описания будут автоматически сгенерированы сервис, клиент, методы и все интерфейсы. В результате весь шаблонный код будет написан и можно сразу приступать к написанию бизнес-логики. Для изменеия сервиса (например добавления нового метода, события или параметров запроса) следует в первую очередь изменить файл описания service.schema.json, а затем перегенерировать на его основе сервис. Уже написанная вами логика не пропадет, но все изменения будут учтены в коде.
- Струткура сервиса. На наш взгляд самая декларативная структура сервиса следующего вида.
```
Service/
├── domain/
│   ├── aggregates/
│   │   ├── Aggregate_1/
│   │   │   ├── fixtures/
│   │   │   │   ├── fixture_1.json
│   │   │   │   ├── fixture_1.json
│   │   │   │   └── ...
│   │   │   ├── Aggregate.ts
│   │   │   ├── Aggregate.interface.ts
│   │   │   ├── Aggregate.test.ts
│   │   │   └── index.ts
│   │   └── Aggregate_2/
│   │       ├── fixtures/
│   │       │   ├── fixture_1.json
│   │       │   ├── fixture_1.json
│   │       │   └── ...
│   │       ├── Aggregate.ts
│   │       ├── Aggregate.interface.ts
│   │       ├── Aggregate.test.ts
│   │       └── index.ts
│   └── ports/
│       ├── index.ts
│       └── repository.ts
├── methods/
│   ├── Method_1/
│   │   ├── index.ts
│   │   ├── index.test.ts
│   │   └── ...
│   ├── Method_2/
│   │   ├── index.ts
│   │   ├── index.test.ts
│   │   └── ...
│   └── ...
├── repository/
│   └── index.ts
├── index.ts
├── interfaces.ts
├── service.ts
├── start.ts
├── inversify.config.ts
├── inversify.types.ts
├── service.schema.json
├── package.json
├── package-lock.json
└── tsconfig.json
``` 
  - `domain` - каталог содержит в себе все классы предметной области сервиса и интерфейсы портов необходимыч для ее работы;
    - `aggregates` - каталог с агрегатами предметной области;
      - `Aggregate` - каталог агрегата. Например User;
        - `Aggregate.ts` - класс агрегата;
        - `Aggregate.interface.ts` - интерфейсы агрегата. Например интерфейс параметров для создания экземпляра агрегата или интерфейс представления агрегата;
        - `Aggregate.test.ts` - тесты для агрегата;
        - `fixtures` - фикстуры для тестирования агрегата;
        - `index.ts` - реэкспорт агрегата и его интерфейсов;
    - `ports` - каталог содержит интерфейсы для всех необходимых логики портов;
      - `repository.ts` - для примере файл интерфейса необходимого репозитория для хранения агрегатов;
      - `index.ts` - реэкспорт портов и его интерфейсов;
    - `methods` - каталог с синхронными методами сервиса. Генерируется автоматически;
      - `Method_1` - каталог матода;
        - `index.ts` - класс метода;
        - `index.test.ts` - тесты для метода;
      - `repository` - реализация репозитория на основе порта;
    - `index.ts` - файл клиента сервиса. Генерируется автоматически;
    - `interfaces.ts` - интерфесы сервса. Генерируется автоматически;
    - `service.ts` - реализация сервиса. Генерируется автоматически;
    - `start.ts` - точка входа для запуска сервиса. Генерируется автоматически;
    - `inversify.config.ts` - DI контейнре. Рекомендация;
    - `inversify.types.ts` - DI контейнер. Рекомендация;
    - `service.schema.json` - описание сервиса;

В общих чертах вся бизнес-логика сконцентрирована в двух метсах структуры:

- Агрегаты предметной области. В мотодах агрегатов содержится чистая бизнес-логика.
- Методы сервиса. Методы содержат часть бизнес-логики сервиса и конкретного метода сервиса, а также служит связующим звеном бизнес-логики агрегата и портов.

## Пример использования

Пример использования инструментов тулкита находится в каталоге `examples`.

Все три сервиса созданы для реализации тестовой логики "Странная сумма":

1. Во вход необходимо передать два числа a и b.
2. На первом этапе логика сервисов сложит эти два числа между собой. Полученная сумма будет использована в качестве максимального количества чисел из ряда Фибоначчи.
3. На последнем этапе, получив последовательность чисел, логика сложит их между собой и вернет ответ.

## Сворачивание сервисов в монолитное приложение

Библиотека поддерживает возможность сворачивать микросервисы в одно монолитное приложение. Для реализации этой возможности необходимо придерживаться [рекомендаций](#рекомендации). Для сворачивания в монолит необходимо использовать отдельную точку входа в приложение. Точка входа должна находиться в сервисе предоставляющем внешнее API к методам приложения. Логика точки входа в монолитную версию приложения следующая. Создается экземпляр сервиса без передачи в него подключения к NATS. В таком случае вместо NATS в качестве брокера будет использована внутреняя реализация брокера на основе встроенного объекта EventEmitter. Доступ в созданному брокеру можно получить через открытое свойство сервиса broker. После создания корневого сервиса необходимо запустить остальные сервисы передав полученный брокер корневого сервиса. За счет этого все сервисы приложения будут использовать один внутренний брокер. При создании клиентов при использовании инъекций также будет использован этот броке. Единый внутренний брокер свяжет дерево сервисов в одно приложение и позволит запустить весь код сервисной архитектуры в монолитном режиме. Пример точки входа для монолитного режима и скрипт сборки можно посмотреть в examples. [Точка входа](./examples/HttpGate/start.mono.ts). 

```
        ┌───────────┐
        │ HTTP_GATE │
        └─────┬─────┘
    ┌─────────┴─────────┐
┌───┴───┐         ┌─────┴─────┐
│ Logic │         │ Service_1 │
└───┬───┘         └─────┬─────┘
    │            ┌──────┴───────┐
 ┌──┴───┐  ┌─────┴─────┐  ┌─────┴─────┐
 │ Math │  │ Service_2 │  │ Service_3 │
 └──────┘  └───────────┘  └───────────┘
```

### Описание каталога `examples`

1. `HttpGate` 一 cервис предоставляет http api с одним маршрутом `POST /math/weird/sum`. В качестве тела запроса необходимо передать json. Например:

```json
{
  "a": 5,
  "b": 5
}
```

После получения запроса сервис HttpGate синхронно через брокер вызывает сервис Logic и, получив от него ответ, возвращает результат в качестве ответа на запрос.

2. `LogicService` 一 сервис реализует логику "Странной суммы". Сам сервис ничего не вычисляет, а лишь использует другой сервис `MathService`:

- Получив два числа от `HttpGate`, `LogicService` синхронно вызывает метод сервиса `Math.sum`, который складывает два переданных числа.
- Затем сервис вызывает метод `Math.Fibonnacci`, в который передает результат предыдущего действия и в качестве ответа получает поток с числами Фибоначчи.
- Получив поток чисел, сервис передает этот поток в метод `Math.SumStream`, который складывает все числа в потоке и в ответе возвращается одно число, которое и является "Странной суммой".
- В завершении последней операции сервис генерирует событие `Elapsed`, в которое передает затраченное на выполнение вычислений время.

3. `MathService` 一 сервис реализует 3 метода: `Sum`, `Fibonacci` и `SumStream`, описанные выше. Помимо этих методов, сервис генерирует также два события:

- При вызове метода `SumStream` сервис генериует обычное событие `Notify`.
- После завершения вычислений сервис генерирует событие `Elapsed`, в которое передает затраченное на выполнение вычислений время. Событие `Elapsed` описано как Jet-stream.

В результате запросов к тестовым сервисам генерируются трассировки следующего вида:

![Таймлайн](./examples/misc/trace_1.png)

![Таймлайн](./examples/misc/trace_1.png)



