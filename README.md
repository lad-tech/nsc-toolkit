[![Coverage Status](https://coveralls.io/repos/github/lad-tech/nsc-toolkit/badge.svg?branch=main)](https://coveralls.io/github/lad-tech/nsc-toolkit?branch=main)
[![Known Vulnerabilities](https://snyk.io/test/github/lad-tech/nsc-toolkit/badge.svg)](https://snyk.io/test/github/lad-tech/nsc-toolkit)

## О библиотеке

`nsc-toolkit (NATS service creator toolkit)` 一 это набор инструментов для создания сервис-ориентированной архитектуры.

Основная идеология тулкита заключается в установке минимального количества зависимостей, что позволяет создавать сервисы с помощью инструментов кодогенерации на основе простого описания в JSON-формате.

Основным средством коммуникации между сервисами в обычном режиме работы является брокер сообщений [NATS](https://nats.io/). Применяются четыре основных способа:

1. Синхронный (`request`/`reply`) через брокер сообщений. Используется, если одному сервису, чтобы продолжать выполнять свою логику, требуются данные из другого сервиса.
2. События (`pub`/`sub`). События используются, когда сервису необходимо оповестить другие сервисы о произошедшем событии, но кто слушает и обрабатывает эти события, сервису неизвестно. Это дает возможность строить независимые между собой сервисы для создания архитектуры на основе событий 一 Event-driven architecture (EDA).
3. Web-потоки на основе `HTTP 1.1`. Этот метод используется, если сервису требуется передать в другой сервис поток данных. Например, список из миллиона пользователей или любые другие объемные данные, включая бинарные. Тогда брокер выступает только как средство балансировки нагрузки и не участвует в передаче данных напрямую. Данные передаются с помощью web-потока из одного сервиса в другой через прямое соединение. Метод сервиса в качестве входных параметров может принимать поток данных и отдавать его в качестве ответа.
4. Jet-streams используют возможности брокера NATS. Jet-streams похож на `pub`/`sub`, но предоставляет возможность хранить сообщения на самом брокере. Такой тип коммуникации позволяет реализовывать более безопасный способ общения между сервисами на основе событий. События, если на них нет подписчиков на текущий момент, не пропадут, а сохранятся на самом брокере.

Все четыре способа коммуникации между сервисами реализуются средствами библиотеки и описываются в JSON.

## Возможности

- Простота и минимальное количество зависимостей за счет снижения уровня вариативности
- Схема взаимодействия `request`/`reply`
- Схема взаимодействия `pub`/`sub`
- Использование Web-streams
- Использование Jet-streams
- Сквозной таймаут для запросов
- Трассировки
- Межсервисное кэширование
- Валидация входных и выходных параметров методов сервиса на основе [JSON Schema](https://json-schema.org/).
- Логирование с учетом контекста
- Декораторы для инъекции зависимостей в методы сервиса
- Сервисный http-маршрут для проб, который поднимается вместе со стартом сервиса (доступен `GET [host]/healthcheck HTTP/1.1`)
- Сворачивание написанных сервисов в монолитное приложение без использования брокера NATS с сохранением всего спектра перечисленных функциональностей. Разные типы архитектуры (микросервисы или монолит) собираются из одной кодовой базы. Это может происходить параллельно в одном пайплайне CI/CD.

## Быстрый старт

Для обзора возможностей библиотеки рекомендуется использовать пример из каталога `examples`, который состоит из 3-х сервисов. Подробно реализация логики описана в пункте [Пример использования](#пример-использования).

Для того, чтобы запустить пример, необходимо:

1. клонировать репозиторий с библиотекой и установить зависимости:

```
npm i
```

2. дополнительно зайти в каталог `examples` с сервисом `HttpGate`

```
cd ./examples/HttpGate
```

и установить там зависимости, так как для реализации HTTP-API используется библиотека Fastify:

```
npm i
```

3. после установки зависимостей можно запустить сервисы.

### Переменные окружения

- `DEFAUL_RESPONSE_TIMEOUT` 一 внешнее ограничение тайм-аута при запросе в секундах. Используется при первоначальном формировании времени тайм-аута в багаже по формуле `Date.now() + DEFAULT_RESPONSE_TIMEOUT`;
- `OTEL_AGENT` 一 хост агента по сбору распределенных трассировок.

## Основные компоненты библиотеки

Для реализации сервисов используются следующие компоненты:

1. Файл service.schema.json. Каждый сервис в первую очередь описывается с помощью формата json. Схема описания следующая.

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "methods": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "action": { "type": "string" },
          "description": { "type": "string" },
          "options": { "$ref": "#/$defs/options" },
          "request": { "type": "object" },
          "response": { "type": "object" }
        },
        "required": ["action", "description", "options"]
      }
    },
    "events": {
      "type": "object",
      "properties": {
        "list": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "action": { "type": "string" },
              "options": {
                "type": "object",
                "properties": {
                  "stream": { "type": "boolean" }
                },
              },
              "description": { "type": "string" },
              "event": { "type": "object" }
            },
            "required": ["action", "description", "event"]
          },
        },
        "streamOptions": {
          "type": "object",
          "properties": {
            "prefix": { "type": "string" },
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "action": { "type": "string" },
                  "storage": { "type": "string" },
                  "retentionPolicy": { "type": "string" },
                  "discardPolicy": { "type": "string" },
                  "messageTTL": { "type": "number" },
                  "duplicateTrackingTime": { "type": "number" },
                  "replication": { "type": "number" },
                  "rollUps": { "type": "boolean" }
                },
                "required": ["action"]
              }
            }
          },
          "required": ["prefix", "actions"]
        }
      },
      "required": ["list"]
    }
  },
  "required": ["name", "description", "methods"],

  "$defs": {
    "options": {
      "type": "object",
      "properties": {
        "useStream": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        },
        "cache": { "type": "number" },
        "runTimeValidation": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        }
      }
    }
  }
}
```

- `name` 一 название сервиса;
- `description` 一 описание сервиса;
- `methods` 一 набор методов для реализации схемы `request`/`reply`;
  - `action` 一 идентификатор запроса;
  - `description` 一 описание метода;
  - `request` 一 JSON Schema входных данных;
  - `response` 一 JSON Schema выходных данных;
  - `options` 一 настройки метода;
    - `useStream` 一 использование Web-стримов для входных и выходных данных;
      - `request` 一 Web-стрим на входе;
      - `response` 一 Web-стрим на выходе;
    - `cache` 一 кэширование запроса (задается в минутах);
    - `runTimeValidation` 一 использование runtime для валидации параметров;
      - `request` 一 для входных данных;
      - `response` 一 для выходных данных;
- `events` 一 набор событий, генерируемый сервисом для реализации схемы `pub`/`sub`;
  - `list` - массив объектов событий генерируемых сервисом;
    - `action` - идентификатор события;
    - `description` - описание события;
    - `options` - необязательные настройки события;
      - `stream` - булевый флаг говорящий о том, что событие является стримом;
    - `event` - JSON Schema события;
  - `name` 一 идентификатор события;
  - `description` 一 описание события;
  - `event` 一 JSON Schema события;
- `streamOptions` - настройки стрима;
  - `prefix` - префикс ко всем темам у которых включена опция stream: true;
  - `actions` - массив объектов настроек стримов;
    - `action` - паттерн для тем на которые будут применяться данные настройки. Если указана * то применяется ко всем событиям с опцией stream: true;
    - `storage` - Где будут храниться сообщения стрима. Доступные варианты 'file' | 'memory'. По умолчанию 'file';
    - `retentionPolicy` - По каким правилам будут удаляться сообщения из стрима. Доступные варианты 'limits' | 'interest' | 'workQueue'. По умолчанию 'limits';
    - `discardPolicy` - Определяет какие сообщения будут отброшены при достижении лимита. Доступные варианты 'old' | 'new'. По умолчанию `old`;
    - `messageTTL` - Срок жизни сообщения. Задается в секундах. По умолчанию 2 недели;
    - `duplicateTrackingTime` - Временной отрезок на котором работает дедубликация сообщений. Задается в секундах. По умолчанию 1 день;
    - `replication` - Количество реплик стрима. По умолчанию 1;
    - `rollUps` - Флаг разрешающий удалить все сообщения из стрима. По умолчанию true;

Файл позволяет описать все возможности создаваемого сервиса. Его синхронные методы, генерируемые сообщения и описать при необходимости настройки стримов для сообщений. Сервис предполагается создавать из описания с помощью кодогенерации. Библиотека для кодогенерации сервиса из описания [nsc-cli](https://github.com/lad-tech/nsc-cli).

2. Класс Service. Для того чтобы создать сервис необходимо создать экземпляр этого класса и вызвать метод start. Принимаемые параметры при создании экземпляра.

- `name` - имя сервиса;
- `brokerConnection` - подключение к брокеру NATS. Параметр необязательный. Если не передать будет использоваться внутренняя реализация брокера. Это необходимо для реализации возможности сборки сервисов в монолитное приложение;
- `methods` - массив методов. BaseMethod это еще один базовый класс библиотеки. Для того что бы создать метод с бизнес-логикой, необходимо расширить класс BaseMethod;
- `events` - описание генерируемых событий. Следует передать весь блок events из service.schema.json;
- `cache` - настройки межмикросервисного кеширования;
  - `service` - реализация интерфеса сервиса кеширования;
  - `timeout` - время в рамках которого необходимо ожидать ответа от кеша. Задается в миллисекундах;
- `loggerOutputFormatter` - реализация класса форматера для логов. Для логирования используется библиотека [@lad-tech/toolbelt](https://github.com/lad-tech/toolbelt);
- `gracefulShutdown` - настройки по завершению работы сервиса;
  - `additional` - массив дополнительных сервисов, которые могут завершать свою работу. Необходимо чтобы сервисы реализовывали необходимый интерфейс;
  - `timeout` - время в рамках которого стоит ожидать штатной остановки сервиса;

Публичные методы:

- `getRootBaggage` - получить корневой багаж для распределенной трассировки. Источником может служить заголовки http запроса. Если подобного рода источники отсутствуют создается новый корневой багаж;
- `endRootSpan` - завершение корневого Span по id трассировки. Необхлдимо для внедорения распределенных трассировок;
- `buildService` - метод создает экземпляр клиента. Все используемые при запросах клиенты (сервисы), для использования полного функционала билбиотеки, должны создаваться через этот метод;
- `start` - запуск сервиса;
- `stop` - остановка сервиса;

3. Класс Client.

## Пример использования

Пример использования инструментов тулкита находится в каталоге `examples`.

Все три сервиса созданы для реализации тестовой логики "Странная сумма":

1. Во вход необходимо передать два числа a и b.
2. На первом этапе логика сервисов сложит эти два числа между собой. Полученная сумма будет использована в качестве максимального количества чисел из ряда Фибоначчи.
3. На последнем этапе, получив последовательность чисел, логика сложит их между собой и вернет ответ.

### Описание каталога `examples`

1. `HttpGate` 一 cервис предоставляет http api с одним маршрутом `POST /math/weird/sum`. В качестве тела запроса необходимо передать json. Например:

```json
{
  "a": 5,
  "b": 5
}
```

После получения запроса сервис HttpGate синхронно через брокер вызывает сервис Logic и, получив от него ответ, возвращает результат в качестве ответа на запрос.

2. `LogicService` 一 сервис реализует логику "Странной суммы". Сам сервис ничего не вычисляет, а лишь использует другой сервис `MathService`:

- Получив два числа от `HttpGate`, `LogicService` синхронно вызывает метод сервиса `Math.sum`, который складывает два переданных числа.
- Затем сервис вызывает метод `Math.Fibonnacci`, в который передает результат предыдущего действия и в качестве ответа получает поток с числами Фибоначчи.
- Получив поток чисел, сервис передает этот поток в метод `Math.SumStream`, который складывает все числа в потоке и в ответе возвращается одно число, которое и является "Странной суммой".
- В завершении последней операции сервис генерирует событие `Elapsed`, в которое передает затраченное на выполнение вычислений время.

3. `MathService` 一 сервис реализует 3 метода: `Sum`, `Fibonacci` и `SumStream`, описанные выше. Помимо этих методов, сервис генерирует также два события:

- При вызове метода `SumStream` сервис генериует обычное событие `Notify`.
- После завершения вычислений сервис генерирует событие `Elapsed`, в которое передает затраченное на выполнение вычислений время. Событие `Elapsed` описано как Jet-stream.

В результате запросов к тестовым сервисам генерируются трассировки следующего вида:

![Таймлайн](./examples/misc/trace_1.png)

![Таймлайн](./examples/misc/trace_1.png)



