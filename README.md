[![Coverage Status](https://coveralls.io/repos/github/lad-tech/nsc-toolkit/badge.svg?branch=main)](https://coveralls.io/github/lad-tech/nsc-toolkit?branch=main)
[![Known Vulnerabilities](https://snyk.io/test/github/lad-tech/nsc-toolkit/badge.svg)](https://snyk.io/test/github/lad-tech/nsc-toolkit)

## Overview

nsc-toolkit (NATS service creator toolkit) - это набор инструментов для создания сервис-ориентированная архитектуры. Основным средством коммуникации между сервисами в обычном режиме работы является брокер сообщений [NATS](https://nats.io/). Для коммуникации сервисы используют 4 основных способа:

1. Синхронный (request/reply) через брокер сообщений. Необходим если одному сервису для продолжения выполнения своей логики требуются данные из другого сервиса и без них дальнейшая работа невозможна.
2. События (pub/sub). События используются когда сервису необходимо оповестить другие сервисы о неком произошедшем событии, но при этом кто слушает и обрабатывает такие события самому сервису неизвестно. Это дает возможность строить совершенно независимые между собой сервисы для построения архитектуры на основе событий (Event-driven architecture EDA). 
3. Web-потоки на основе HTTP 1.1. Этот метод использщуется если сервису требуется передать в другой сервис поток данных. Например список из миллиона пользователей или любые другие объемные данны включая бинарные. В данным случае брокер выступает только как средство балансировки нагрузки и не участвует в передачи данных напрямую. Данные передаются с помощью web-потока из одного сервиса в другой через прямое соединение. Причем метод серивиса в качестве входных параметров может принимать поток и при этом в качестве ответа может также отдавать поток. 
4. Jet-streams успользую возможности брокера NATS. Jet-streams - это тот же pub/sub, но предоставляющий возможности по хранению сообщений на самом брокере. Такой тип коммуникации позволяет реализовывать более безопастный способ общения между сервисами на основе событий. События не пропадут если на них нет подписчиков на данный момент, а сохранятся на самом брокере. 

Основная идеология тулкита - это простой инструмент с минимальным количеством зависимостей позволяющий создавать сервисы с помощью интсрументов кодогенерации на основе простого описания в JSON формате. Все 4 способа коммуникации описываются между сервисами описываются в JSON и реализуются средствами библиотеки. 

## Core features

* Простота и минимальное количество зависимостей за счет снижения уровня вариативности
* Схема взаимодействия request/reply
* Схема взаимодействия pub/sub
* Использование Web-streams
* Использование Jet-streams
* Сквозной таймаут для запросов
* Трассировки
* Межсервисное кеширование
* Валидация входных и выходных параметров методов сервиса на основе [JSON Schema](https://json-schema.org/).
* Логирование с учетом контекста.
* Декораторы для инъекции зависимостей в методы сервиса
* Сервисный http маршрут для проб. Поднимается вместе со стартом сервиса. Доступен **GET [host]/healthcheck HTTP/1.1**
* Сворачивание написанных сервисов в монолитное приложение без использования брокера NATS с сохранением всего спектра перечисленного функционала. Разные типы архитектуры (микросервисы или монолит) собираются из одной кодовой базы. Это может происходить параллельно в одном пайплайне CI/CD.

## Quick start

Для обзора возможностей библиотеки рекомендуется использовать пример написанный специально для этих целей. Пример находится в каталоге examples и состоит из 3х сервисов. Все три сервиса созданы для реализации логики "Странная сумма". Суть в следующем. В вход необходимо передать два числа a и b.  На первом этапе логика сервисов сложит эти два числа между собой. Полученная сумма будет использованна в качестве максимального количества чисел из ряда Фибоначчи. На последнем этапе, получив последовательность числе логика сложит их между собой и вернет ответ. Данная логика не имеет никакого смысла и придуманна только лишь для того, что бы продемонстрировать возможности библиотеки. 

1. HttpGate - Сервис предоставляет http api с одним маршрутом POST /math/weird/sum. В качестве тела запроса необходимо передать json. Например: 

```json
{
  "a": 5,
  "b": 5
}
```

После получения запроса HttpGate синхронно через брокер вызывает сервис Logic и получив от него ответ возвращает результат в качестве ответа на запрос.

2. Logic - сервис реализует всю логику "Странной суммы". Сам сервис ничего не вычисляет, а лишь использует другой сервис Math. получив два числа от HttpGate сервис Logic синхронно вызывает метод сервиса Math.sum, который складывает два переданныхз числа. Затем сервис вызывает метод Math.Fibonnacci в который передает результат предыдущего действия и в качестве ответа получает поток с числами Фибоначчи. Получив пото сервис передает этот потом в метод Math.SumStream, который складывает все числа в потоке и в ответе возвращается одно число, которое и является "Странной суммой". В завершении последней операцией сервис генерирует событие Elapsed в которое передает затраченное на выполнение вычислений время
3. Math - сервис реализует 3 метода Sum, Fibonacci и SumStream описанные ранее. Помимо этих методов сервис генерирует также два события. При вызове метода SumStream сервис генериует обычное событие Notify, а по завершению вычислений генерирует событие Elapsed в которое передает затраченное на выполнение вычислений время. Событие Elapsed описано как Jet-stream.

Для того, чтобы запустить этот пример необходимо клонировать репозиторий с библиотекой и установить зависимости.
```
npm i
```

Затем дополнительно зайти в каталог с сервисов HttpGate

```
cd ./examples/HttpGate
```

И установит звисимости там. Поскольку для реализации HTTP-API используется библиотека Fastify.

```
npm i
```

После установки зависимостей можно запустить сервисы.

## Схема описания сервиса

Сервисы описываются в JSON файле. Схема:

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "methods": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "action": { "type": "string" },
          "description": { "type": "string" },
          "options": { "$ref": "#/$defs/options" },
          "request": { "type": "object" },
          "response": { "type": "object" }
        },
        "required": [ "action", "description", "options" ]
      }
    },
    "events": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "description": { "type": "string" },
          "message": { "type": "object" }
        },
        "required": [ "action", "description", "options", "message" ]
      }
    }
  },
  "required": [ "name", "description", "methods" ],

  "$defs": {
    "options": {
      "type": "object",
      "properties": {
        "useStream": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        },
        "cache": { "type": "number" },
        "runTimeValidation": {
          "type": "object",
          "properties": {
            "request": { "type": "boolean" },
            "response": { "type": "boolean" }
          }
        }
      }
    }
  }
}
```

- **name** - Название сервиса.
- **description** - Описание сервиса.
- **methods** - Набор методов для реализации схемы request/reply
  - **action** - Идентификатор запроса.
  - **description** - Описание метода.
  - **request** - JSON Schema входных данных.
  - **response** - JSON Schema выходных данных.
  - **options** - Настройки метода.
    - **useStream** - Использование Web-стримов для входных и выходных данных.
      - **request** - Web-стрим на входе.
      - **response** - Web-стрим на выходе.
    - **cache** - Кешировать запрос. Задается в минутах.
    - **runTimeValidation** - Использовать run time валидацию параметров
      - **request** - Для входных данных.
      - **response** - Для выходных данных.
- **events** - Набор событий генерируемый сервисом для реализации схемы pub/sub
  - **name** - Идентификатор события.
  - **description** - Описание события.
  - **event** - JSON Schema события.

## Пример использования

Пример использования инструментов тулкита находится в папке **exaples**

В результате запросов к тестовым сервисам генерируются трассировки следующего вида

![Таймлайн](./examples/misc/trace_1.png)

![Таймлайн](./examples/misc/trace_1.png)

## Описание переменных окружения

 - **DEFAUL_RESPONSE_TIMEOUT** - Внешнее ограничение таймаута при запросе в секундах. Используется при первоначальном формировании времени таймаута в багаже по формуле *Date.now() + DEFAULT_RESPONSE_TIMEOUT*

 - **OTEL_AGENT** - Хост агента по сбору распределенных трассировок.